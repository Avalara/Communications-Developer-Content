=begin comment

SaasPro

APIs to interface with communications tax engine.<br />The API requires Basic authentication.<br />Users with access to multiple clients must also set request header parameter for <code>client_id</code>.<br />Set <code>client_profile_id</code> to specify profile to be used for taxation.

The version of the OpenAPI document: v2

Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::Object::Tax;

require 5.6.0;
use strict;
use warnings;
use utf8;
use JSON qw(decode_json);
use Data::Dumper;
use Module::Runtime qw(use_module);
use Log::Any qw($log);
use Date::Parse;
use DateTime;


use base ("Class::Accessor", "Class::Data::Inheritable");

#
#Tax data for individual line item.
#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech). Do not edit the class manually.
# REF: https://openapi-generator.tech
#

=begin comment

SaasPro

APIs to interface with communications tax engine.<br />The API requires Basic authentication.<br />Users with access to multiple clients must also set request header parameter for <code>client_id</code>.<br />Set <code>client_profile_id</code> to specify profile to be used for taxation.

The version of the OpenAPI document: v2

Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
__PACKAGE__->mk_classdata('attribute_map' => {});
__PACKAGE__->mk_classdata('openapi_types' => {});
__PACKAGE__->mk_classdata('method_documentation' => {}); 
__PACKAGE__->mk_classdata('class_documentation' => {});

# new plain object
sub new { 
    my ($class, %args) = @_; 

    my $self = bless {}, $class;

    $self->init(%args);
    
    return $self;
}

# initialize the object
sub init
{
    my ($self, %args) = @_;

    foreach my $attribute (keys %{$self->attribute_map}) {
        my $args_key = $self->attribute_map->{$attribute};
        $self->$attribute( $args{ $args_key } );
    }
}

# return perl hash
sub to_hash {
    my $self = shift;
    my $_hash = decode_json(JSON->new->convert_blessed->encode($self));

    return $_hash;
}

# used by JSON for serialization
sub TO_JSON { 
    my $self = shift;
    my $_data = {};
    foreach my $_key (keys %{$self->attribute_map}) {
        if (defined $self->{$_key}) {
            $_data->{$self->attribute_map->{$_key}} = $self->{$_key};
        }
    }

    return $_data;
}

# from Perl hashref
sub from_hash {
    my ($self, $hash) = @_;

    # loop through attributes and use openapi_types to deserialize the data
    while ( my ($_key, $_type) = each %{$self->openapi_types} ) {
        my $_json_attribute = $self->attribute_map->{$_key}; 
        if ($_type =~ /^array\[(.+)\]$/i) { # array
            my $_subclass = $1;
            my @_array = ();
            foreach my $_element (@{$hash->{$_json_attribute}}) {
                push @_array, $self->_deserialize($_subclass, $_element);
            }
            $self->{$_key} = \@_array;
        } elsif ($_type =~ /^hash\[string,(.+)\]$/i) { # hash
            my $_subclass = $1;
            my %_hash = ();
            while (my($_key, $_element) = each %{$hash->{$_json_attribute}}) {
                $_hash{$_key} = $self->_deserialize($_subclass, $_element);
            }
            $self->{$_key} = \%_hash;
        } elsif (exists $hash->{$_json_attribute}) { #hash(model), primitive, datetime
            $self->{$_key} = $self->_deserialize($_type, $hash->{$_json_attribute});
        } else {
            $log->debugf("Warning: %s (%s) does not exist in input hash\n", $_key, $_json_attribute);
        }
    }
  
    return $self;
}

# deserialize non-array data
sub _deserialize {
    my ($self, $type, $data) = @_;
    $log->debugf("deserializing %s with %s",Dumper($data), $type);

    if ($type eq 'DateTime') {
        return DateTime->from_epoch(epoch => str2time($data));
    } elsif ( grep( /^$type$/, ('int', 'double', 'string', 'boolean'))) {
        return $data;
    } else { # hash(model)
        my $_instance = eval "WWW::OpenAPIClient::Object::$type->new()";
        return $_instance->from_hash($data);
    }
}



__PACKAGE__->class_documentation({description => 'Tax data for individual line item.',
                                  class => 'Tax',
                                  required => [], # TODO
}                                 );

__PACKAGE__->method_documentation({
    'bill' => {
        datatype => 'boolean',
        base_name => 'bill',
        description => 'Indicates if tax is billable to customer.',
        format => '',
        read_only => '',
            },
    'cmpl' => {
        datatype => 'boolean',
        base_name => 'cmpl',
        description => 'Indicates if the tax is to be reported to jurisdiction.',
        format => '',
        read_only => '',
            },
    'tm' => {
        datatype => 'double',
        base_name => 'tm',
        description => 'Taxable measure.',
        format => '',
        read_only => '',
            },
    'calc' => {
        datatype => 'int',
        base_name => 'calc',
        description => 'Calculation type.',
        format => '',
        read_only => '',
            },
    'cat' => {
        datatype => 'string',
        base_name => 'cat',
        description => 'Tax category name.',
        format => '',
        read_only => '',
            },
    'cid' => {
        datatype => 'int',
        base_name => 'cid',
        description => 'Tax category ID.',
        format => '',
        read_only => '',
            },
    'name' => {
        datatype => 'string',
        base_name => 'name',
        description => 'Tax name.',
        format => '',
        read_only => '',
            },
    'exm' => {
        datatype => 'double',
        base_name => 'exm',
        description => 'Exempt sale amount.',
        format => '',
        read_only => '',
            },
    'lns' => {
        datatype => 'int',
        base_name => 'lns',
        description => 'Lines.',
        format => '',
        read_only => '',
            },
    'min' => {
        datatype => 'double',
        base_name => 'min',
        description => 'Minutes.',
        format => '',
        read_only => '',
            },
    'pcd' => {
        datatype => 'int',
        base_name => 'pcd',
        description => 'PCode for reporting jurisdiction.',
        format => '',
        read_only => '',
            },
    'taxpcd' => {
        datatype => 'int',
        base_name => 'taxpcd',
        description => 'PCode for taxing jurisdiction.  Only returned if return extended tax data flag is true',
        format => '',
        read_only => '',
            },
    'rate' => {
        datatype => 'double',
        base_name => 'rate',
        description => 'Tax rate.',
        format => '',
        read_only => '',
            },
    'sur' => {
        datatype => 'boolean',
        base_name => 'sur',
        description => 'Indicates if this tax is a surcharge.',
        format => '',
        read_only => '',
            },
    'tax' => {
        datatype => 'double',
        base_name => 'tax',
        description => 'Tax amount.',
        format => '',
        read_only => '',
            },
    'lvl' => {
        datatype => 'int',
        base_name => 'lvl',
        description => 'Tax level ID.',
        format => '',
        read_only => '',
            },
    'tid' => {
        datatype => 'int',
        base_name => 'tid',
        description => 'Tax type ID.',
        format => '',
        read_only => '',
            },
    'usexm' => {
        datatype => 'boolean',
        base_name => 'usexm',
        description => 'Flag indicating if tax was user exempted  Only returned if return extended tax data flag is true',
        format => '',
        read_only => '',
            },
    'notax' => {
        datatype => 'boolean',
        base_name => 'notax',
        description => 'Flag indicating the item is a no tax entry  There were no taxes generated, this entry is to convey back the taxing jurisdiction that was used in the response  Only returned if return extended tax data flag is true',
        format => '',
        read_only => '',
            },
    'trans' => {
        datatype => 'int',
        base_name => 'trans',
        description => 'Transaction type used to calculate tax  For bundles will be specific bundled item transaction type  Only returned if return extended tax data flag is true',
        format => '',
        read_only => '',
            },
    'svc' => {
        datatype => 'int',
        base_name => 'svc',
        description => 'Service type used to calculate tax  For bundles will be specific bundled item service type  Only returned if return extended tax data flag is true',
        format => '',
        read_only => '',
            },
    'chg' => {
        datatype => 'double',
        base_name => 'chg',
        description => 'Charge used to calculate tax  For bundles will be the percentage of charge applied to bundled item  For tax inclusive calls will be the calculated charge  Only returned if return extended tax data flag is true',
        format => '',
        read_only => '',
            },
});

__PACKAGE__->openapi_types( {
    'bill' => 'boolean',
    'cmpl' => 'boolean',
    'tm' => 'double',
    'calc' => 'int',
    'cat' => 'string',
    'cid' => 'int',
    'name' => 'string',
    'exm' => 'double',
    'lns' => 'int',
    'min' => 'double',
    'pcd' => 'int',
    'taxpcd' => 'int',
    'rate' => 'double',
    'sur' => 'boolean',
    'tax' => 'double',
    'lvl' => 'int',
    'tid' => 'int',
    'usexm' => 'boolean',
    'notax' => 'boolean',
    'trans' => 'int',
    'svc' => 'int',
    'chg' => 'double'
} );

__PACKAGE__->attribute_map( {
    'bill' => 'bill',
    'cmpl' => 'cmpl',
    'tm' => 'tm',
    'calc' => 'calc',
    'cat' => 'cat',
    'cid' => 'cid',
    'name' => 'name',
    'exm' => 'exm',
    'lns' => 'lns',
    'min' => 'min',
    'pcd' => 'pcd',
    'taxpcd' => 'taxpcd',
    'rate' => 'rate',
    'sur' => 'sur',
    'tax' => 'tax',
    'lvl' => 'lvl',
    'tid' => 'tid',
    'usexm' => 'usexm',
    'notax' => 'notax',
    'trans' => 'trans',
    'svc' => 'svc',
    'chg' => 'chg'
} );

__PACKAGE__->mk_accessors(keys %{__PACKAGE__->attribute_map});


1;
